<!DOCTYPE html>
<html lang="en">

<head>
    <title>ğŸ’¬ QChat</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ndDqU0Gzau9qJ1lfW4pNLlhNTkCfHzAVBReH9diLvGRem5+R9g2FzA8ZGN954O5Q" crossorigin="anonymous"></script>

    </head>

    <style>
        th.fit, td.fit {
        white-space: nowrap;
        width: 1%;
        }
    </style>

<body class="container">

<div class="card mt-2">

    <div id="qchat-settings-header" class="card-header">

        <h5 class="mb-0">
            <button
                class="btn"
                data-bs-toggle="collapse"
                data-bs-target="#qchat-settings"
                aria-expanded="true"
                aria-controls="qchat-settings"
            >âš™ï¸ QChat Settings
            </button>
        </h5>

    </div>

    <div id="qchat-settings" class="collapse show" aria-labelledby="qchat-settings-header">

        <div class="card-body">

            <form class="d-flex flex-column flex-md-row align-items-md-center gap-2 mb-2">

                <label for="authorId">Nickname:</label>
                <input type="text" class="form-control" id="authorId" aria-describedby="nickname" placeholder="Enter nickname" value="Geotribu">

                <label for="avatarId">Avatar:</label>
                <input type="text" class="form-control" id="avatarId" aria-describedby="avatar" placeholder="Enter avatar" value="mGeoPackage.svg">

                <label for="channel-dropdown" class="form-label">Channel:</label>
                <select id="channel-dropdown" class="form-select"></select>

                <button class="btn btn-primary" id="connectButton" onclick="onConnectButtonClick(event)">Connect</button>
                <button class="btn btn-outline-primary" id="rulesButton" onclick="onRulesButtonClick(event)">Rules</button>
                <button class="btn btn-outline-primary" id="statusButton" onclick="onStatusButtonClick(event)">Status</button>

            </form>

        </div>
    </div>

</div>

<div class="card mt-2">

    <div id="qchat-header" class="card-header">

        <h5 class="mb-0">
            <button
                id="qchat-header-button"
                class="btn"
                data-bs-toggle="collapse"
                data-bs-target="#qchat"
                aria-expanded="true"
                aria-controls="qchat"
            >ğŸ’¬ QChat
            </button>
        </h5>

    </div>

    <div id="qchat" class="collapse" aria-labelledby="qchat-header">

        <div class="card-body">

            <form class="d-flex flex-column flex-md-row align-items-md-center gap-2 mb-2">

                <label for="messageText">Message:</label>
                <input type="text" class="form-control" id="messageText" aria-describedby="textMessage" placeholder="Your message here" disabled>

                <button class="btn btn-primary" onclick="sendMessage(event)" id="sendButton" disabled>Send</button>

            </form>

            <table class="table">
                <thead>
                    <tr>
                    <th scope="col" class="fit">âŒš<span class="visually-hidden">Time</span></th>
                    <th scope="col" class="fit">ğŸ–¨ï¸<span class="visually-hidden">Printer</span></th>
                    <th scope="col" class="fit">ğŸ§‘<span class="visually-hidden">User</span></th>
                    <th scope="col">Message</th>
                    </tr>
                </thead>
                <tbody id="messages-table-body">
                </tbody>
            </table>
        </div>

    </div>

</div>


<script>

    let websocket = null;
    let connected = false;

    const qchatSettingsElement = document.getElementById("qchat-settings");
    const qchatElement = document.getElementById("qchat");

    const instance = window.location.host;
    const ssl = window.location.protocol.startsWith("https");

    const channelDropdown = document.getElementById("channel-dropdown");

    // populate channels with API call
    const protocol = ssl ? "https" : "http";
    fetch(`${protocol}://${instance}/channels`)
        .then(response => response.json())
        .then(data => {
            data.forEach(channel => {
                const option = document.createElement("option");
                option.value = channel;
                option.text = channel;
                channelDropdown.appendChild(option);
            });
        })
        .catch(error => {
            console.error("Error when fetching channel data:", error);
        });

    const qchatHeaderElement = document.getElementById("qchat-header-button");

    const authorElement = document.getElementById("authorId");
    authorElement.value = `jd_${(Math.random() * 10000).toFixed(0)}`;
    const avatarElement = document.getElementById("avatarId");

    const textMessageElement = document.getElementById("messageText");
    const qchatTableBodyElement = document.getElementById("messages-table-body");

    const timeFormatter = new Intl.DateTimeFormat("fr-FR", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false
    });

    const clearMessages = () => {
        while (qchatTableBodyElement.firstChild) {
            qchatTableBodyElement.removeChild(qchatTableBodyElement.firstChild);
        }
    }

    const displayMessage = (timestamp, messageType, author, message, rowClasses) => {
        // received timestamp is in seconds.
        const messageDate = new Date(timestamp * 1000);

        const rowElement = document.createElement("tr");
        rowElement.classList.add(rowClasses);

        [
            timeFormatter.format(messageDate),
            messageType,
            author,
            message
        ].forEach((text) => {
            const cell = document.createElement("td");
            cell.innerText = text;
            rowElement.appendChild(cell);
        });

        qchatTableBodyElement.prepend(rowElement);
    }

    const displayAdminMessage = (message) => {
        displayMessage(Math.floor(Date.now() / 1000), "ğŸ› ï¸", "Admin", message, "table-warning");
    }

    const onRulesButtonClick = (event) => {
        const protocol = ssl ? "https" : "http";
        fetch(`${protocol}://${instance}/rules`)
            .then(response => response.json())
            .then(data => alert(`Instance rules:\n\n${data.rules}`));
        event.preventDefault()
    }

    const onStatusButtonClick = (event) => {
        const protocol = ssl ? "https" : "http";
        fetch(`${protocol}://${instance}/status`)
            .then(response => response.json())
            .then(data => alert(`Instance status: ${data.status}\n\nUsers:\n${data.channels.map(channel => `${channel.name}: ${channel.nb_connected_users}`).join("\n")}`));
        event.preventDefault()
    }

    const setFormEnabled = (enabled) => {
        channelDropdown.disabled = enabled;
        authorElement.disabled = enabled;
        avatarElement.disabled = enabled;
        textMessageElement.disabled = !enabled;
        document.getElementById("sendButton").disabled = !enabled;
        document.getElementById("connectButton").innerText = enabled ? "Disconnect" : "Connect";
    }

    const setChannelText = (channel, nbUsers) => {
        qchatHeaderElement.innerHTML = `ğŸ’¬ QChat - ${channel} <span class="badge bg-primary">${nbUsers}</span>`;
        document.title = `ğŸ’¬ QChat - ${channel} (${nbUsers})`;
    }

    const onConnectButtonClick = (event) => {
        if (connected) {
            websocket.close();
            event.preventDefault();
            return;
        }

        if (!channelDropdown.value) {
            alert("Channel must be set");
            return;
        }

        const ws_protocol = ssl ? "wss" : "ws";
        const ws_url = `${ws_protocol}://${instance}/channel/${channelDropdown.value}/ws`;
        const user = authorElement.value;

        websocket = new WebSocket(ws_url);

        websocket.onopen = (event) => {
            clearMessages();
            displayAdminMessage(`Connected to channel ${channelDropdown.value}`);
            connected = true;
            setFormEnabled(true);
            setChannelText(channelDropdown.value, "-");
            qchatSettingsElement.classList.remove("show");
            qchatElement.classList.add("show");
            websocket.send(JSON.stringify({type: "newcomer", newcomer: user}));
        }

        websocket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            const type = data.type;

            switch (type) {
                case "uncompliant":
                    displayMessage(data.timestamp, "ğŸ› ï¸", "Admin",`Uncompliant message: ${data.reason}`, "table-warning");
                    break;
                case "text":
                    displayMessage(data.timestamp, "ğŸ’¬", data.author, data.text);
                    break;
                case "image":
                    displayMessage(data.timestamp, "ğŸ–¼ï¸", data.author, `${data.author} sent an image`, "table-info");
                    break;
                case "nb_users":
                    setChannelText(channelDropdown.value, data.nb_users);
                    break;
                case "newcomer":
                    console.log(`${data.newcomer} has joined the channel`);
                    break;
                case "exiter":
                    console.log(`${data.exiter} has left the channel`);
                    break;
                case "like":
                    displayMessage(data.timestamp, "ğŸ‘", data.liker_author, `Liked ${data.liked_author}'s message`, "table-success");
                    break;
                case "geojson":
                    displayMessage(data.timestamp, "ğŸŒ", data.author, `Shared the "${data.layer_name}" layer - ${data.geojson.features.length} features using ${data.crs_authid}`, "table-info");
                    break;
                case "crs":
                    displayMessage(data.timestamp, "ğŸ“", data.author, `Shared the CRS ${data.crs_authid}`, "table-info");
                    break;
                case "bbox":
                    displayMessage(data.timestamp, "ğŸ”³", data.author, `Shared a BBOX using ${data.crs_authid}`, "table-info");
                    break;
                case "position":
                    displayMessage(data.timestamp, "ğŸ“", data.author, `Shared the ${data.x}-${data.y} position using ${data.crs_authid}`, "table-info");
                    break;
                case "model":
                    displayMessage(data.timestamp, "ğŸ§®", data.author, `Shared the model ${data.model_name}`, "table-info");
                    break;
                default:
                    displayAdminMessage(`Unknown message received: ${data}`);
            }
        };

        websocket.onerror = (error) => {
            displayAdminMessage(`Websocket error ${JSON.stringify(error)}`);
            console.log("Websocket error", error);
        };

        websocket.onclose = (event) => {
            connected = false;
            displayAdminMessage("Disconnected from websocket");
            setFormEnabled(false);
            qchatHeaderElement.innerHTML = "ğŸ’¬ QChat";
            document.title = "ğŸ’¬ QChat";
        }

        event.preventDefault();
    }

    const sendMessage = (event) => {
        if (!connected) {
            displayAdminMessage("Not connected to websocket");
            event.preventDefault();
            return;
        }

        if (!textMessageElement.value || !authorElement.value) {
            displayAdminMessage("Impossible: author and message must be set !");
            event.preventDefault();
            return;
        }

        websocket.send(JSON.stringify({type: "text", text: textMessageElement.value, author: authorElement.value, avatar: avatarElement.value}));

        textMessageElement.value = '';
        event.preventDefault();
    }

    window.onload = () => displayAdminMessage("Not connected: please connect to a channel to chat");
</script>
</body>
</html>
